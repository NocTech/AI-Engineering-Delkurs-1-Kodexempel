"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@huggingface";
exports.ids = ["vendor-chunks/@huggingface"];
exports.modules = {

/***/ "(rsc)/./node_modules/@huggingface/inference/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@huggingface/inference/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HfInference: () => (/* binding */ HfInference),\n/* harmony export */   HfInferenceEndpoint: () => (/* binding */ HfInferenceEndpoint),\n/* harmony export */   InferenceOutputError: () => (/* binding */ InferenceOutputError),\n/* harmony export */   audioClassification: () => (/* binding */ audioClassification),\n/* harmony export */   audioToAudio: () => (/* binding */ audioToAudio),\n/* harmony export */   automaticSpeechRecognition: () => (/* binding */ automaticSpeechRecognition),\n/* harmony export */   chatCompletion: () => (/* binding */ chatCompletion),\n/* harmony export */   chatCompletionStream: () => (/* binding */ chatCompletionStream),\n/* harmony export */   documentQuestionAnswering: () => (/* binding */ documentQuestionAnswering),\n/* harmony export */   featureExtraction: () => (/* binding */ featureExtraction),\n/* harmony export */   fillMask: () => (/* binding */ fillMask),\n/* harmony export */   imageClassification: () => (/* binding */ imageClassification),\n/* harmony export */   imageSegmentation: () => (/* binding */ imageSegmentation),\n/* harmony export */   imageToImage: () => (/* binding */ imageToImage),\n/* harmony export */   imageToText: () => (/* binding */ imageToText),\n/* harmony export */   objectDetection: () => (/* binding */ objectDetection),\n/* harmony export */   questionAnswering: () => (/* binding */ questionAnswering),\n/* harmony export */   request: () => (/* binding */ request),\n/* harmony export */   sentenceSimilarity: () => (/* binding */ sentenceSimilarity),\n/* harmony export */   streamingRequest: () => (/* binding */ streamingRequest),\n/* harmony export */   summarization: () => (/* binding */ summarization),\n/* harmony export */   tableQuestionAnswering: () => (/* binding */ tableQuestionAnswering),\n/* harmony export */   tabularClassification: () => (/* binding */ tabularClassification),\n/* harmony export */   tabularRegression: () => (/* binding */ tabularRegression),\n/* harmony export */   textClassification: () => (/* binding */ textClassification),\n/* harmony export */   textGeneration: () => (/* binding */ textGeneration),\n/* harmony export */   textGenerationStream: () => (/* binding */ textGenerationStream),\n/* harmony export */   textToImage: () => (/* binding */ textToImage),\n/* harmony export */   textToSpeech: () => (/* binding */ textToSpeech),\n/* harmony export */   tokenClassification: () => (/* binding */ tokenClassification),\n/* harmony export */   translation: () => (/* binding */ translation),\n/* harmony export */   visualQuestionAnswering: () => (/* binding */ visualQuestionAnswering),\n/* harmony export */   zeroShotClassification: () => (/* binding */ zeroShotClassification),\n/* harmony export */   zeroShotImageClassification: () => (/* binding */ zeroShotImageClassification)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n    audioClassification: ()=>audioClassification,\n    audioToAudio: ()=>audioToAudio,\n    automaticSpeechRecognition: ()=>automaticSpeechRecognition,\n    chatCompletion: ()=>chatCompletion,\n    chatCompletionStream: ()=>chatCompletionStream,\n    documentQuestionAnswering: ()=>documentQuestionAnswering,\n    featureExtraction: ()=>featureExtraction,\n    fillMask: ()=>fillMask,\n    imageClassification: ()=>imageClassification,\n    imageSegmentation: ()=>imageSegmentation,\n    imageToImage: ()=>imageToImage,\n    imageToText: ()=>imageToText,\n    objectDetection: ()=>objectDetection,\n    questionAnswering: ()=>questionAnswering,\n    request: ()=>request,\n    sentenceSimilarity: ()=>sentenceSimilarity,\n    streamingRequest: ()=>streamingRequest,\n    summarization: ()=>summarization,\n    tableQuestionAnswering: ()=>tableQuestionAnswering,\n    tabularClassification: ()=>tabularClassification,\n    tabularRegression: ()=>tabularRegression,\n    textClassification: ()=>textClassification,\n    textGeneration: ()=>textGeneration,\n    textGenerationStream: ()=>textGenerationStream,\n    textToImage: ()=>textToImage,\n    textToSpeech: ()=>textToSpeech,\n    tokenClassification: ()=>tokenClassification,\n    translation: ()=>translation,\n    visualQuestionAnswering: ()=>visualQuestionAnswering,\n    zeroShotClassification: ()=>zeroShotClassification,\n    zeroShotImageClassification: ()=>zeroShotImageClassification\n});\n// src/utils/pick.ts\nfunction pick(o, props) {\n    return Object.assign({}, ...props.map((prop)=>{\n        if (o[prop] !== void 0) {\n            return {\n                [prop]: o[prop]\n            };\n        }\n    }));\n}\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n    return arr.includes(v);\n}\n// src/utils/omit.ts\nfunction omit(o, props) {\n    const propsArr = Array.isArray(props) ? props : [\n        props\n    ];\n    const letsKeep = Object.keys(o).filter((prop)=>!typedInclude(propsArr, prop));\n    return pick(o, letsKeep);\n}\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n    return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */ new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n    if (isUrl(model)) {\n        return null;\n    }\n    const key = `${model}:${accessToken}`;\n    let cachedTask = taskCache.get(key);\n    if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n        taskCache.delete(key);\n        cachedTask = void 0;\n    }\n    if (cachedTask === void 0) {\n        const modelTask = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${model}?expand[]=pipeline_tag`, {\n            headers: accessToken ? {\n                Authorization: `Bearer ${accessToken}`\n            } : {}\n        }).then((resp)=>resp.json()).then((json)=>json.pipeline_tag).catch(()=>null);\n        if (!modelTask) {\n            return null;\n        }\n        cachedTask = {\n            task: modelTask,\n            date: /* @__PURE__ */ new Date()\n        };\n        taskCache.set(key, {\n            task: modelTask,\n            date: /* @__PURE__ */ new Date()\n        });\n        if (taskCache.size > MAX_CACHE_ITEMS) {\n            taskCache.delete(taskCache.keys().next().value);\n        }\n    }\n    return cachedTask.task;\n}\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n    const { accessToken, endpointUrl, ...otherArgs } = args;\n    let { model } = args;\n    const { forceTask: task, includeCredentials, taskHint, wait_for_model, use_cache, dont_load_model, chatCompletion: chatCompletion2 } = options ?? {};\n    const headers = {};\n    if (accessToken) {\n        headers[\"Authorization\"] = `Bearer ${accessToken}`;\n    }\n    if (!model && !tasks && taskHint) {\n        const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n        if (res.ok) {\n            tasks = await res.json();\n        }\n    }\n    if (!model && tasks && taskHint) {\n        const taskInfo = tasks[taskHint];\n        if (taskInfo) {\n            model = taskInfo.models[0].id;\n        }\n    }\n    if (!model) {\n        throw new Error(\"No model provided, and no default model found for this task\");\n    }\n    const binary = \"data\" in args && !!args.data;\n    if (!binary) {\n        headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (wait_for_model) {\n        headers[\"X-Wait-For-Model\"] = \"true\";\n    }\n    if (use_cache === false) {\n        headers[\"X-Use-Cache\"] = \"false\";\n    }\n    if (dont_load_model) {\n        headers[\"X-Load-Model\"] = \"0\";\n    }\n    let url = (()=>{\n        if (endpointUrl && isUrl(model)) {\n            throw new TypeError(\"Both model and endpointUrl cannot be URLs\");\n        }\n        if (isUrl(model)) {\n            console.warn(\"Using a model URL is deprecated, please use the `endpointUrl` parameter instead\");\n            return model;\n        }\n        if (endpointUrl) {\n            return endpointUrl;\n        }\n        if (task) {\n            return `${HF_INFERENCE_API_BASE_URL}/pipeline/${task}/${model}`;\n        }\n        return `${HF_INFERENCE_API_BASE_URL}/models/${model}`;\n    })();\n    if (chatCompletion2 && !url.endsWith(\"/chat/completions\")) {\n        url += \"/v1/chat/completions\";\n    }\n    let credentials;\n    if (typeof includeCredentials === \"string\") {\n        credentials = includeCredentials;\n    } else if (includeCredentials === true) {\n        credentials = \"include\";\n    }\n    const info = {\n        headers,\n        method: \"POST\",\n        body: binary ? args.data : JSON.stringify({\n            ...otherArgs.model && isUrl(otherArgs.model) ? omit(otherArgs, \"model\") : otherArgs\n        }),\n        ...credentials && {\n            credentials\n        },\n        signal: options?.signal\n    };\n    return {\n        url,\n        info\n    };\n}\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n    const { url, info } = await makeRequestOptions(args, options);\n    const response = await (options?.fetch ?? fetch)(url, info);\n    if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n        return request(args, {\n            ...options,\n            wait_for_model: true\n        });\n    }\n    if (!response.ok) {\n        if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n            const output = await response.json();\n            if ([\n                400,\n                422,\n                404,\n                500\n            ].includes(response.status) && options?.chatCompletion) {\n                throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n            }\n            if (output.error) {\n                throw new Error(JSON.stringify(output.error));\n            }\n        }\n        throw new Error(\"An error occurred while fetching the blob\");\n    }\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n        return await response.json();\n    }\n    return await response.blob();\n}\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n    let buffer;\n    let position;\n    let fieldLength;\n    let discardTrailingNewline = false;\n    return function onChunk(arr) {\n        if (buffer === void 0) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        } else {\n            buffer = concat(buffer, arr);\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0;\n        while(position < bufLength){\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10 /* NewLine */ ) {\n                    lineStart = ++position;\n                }\n                discardTrailingNewline = false;\n            }\n            let lineEnd = -1;\n            for(; position < bufLength && lineEnd === -1; ++position){\n                switch(buffer[position]){\n                    case 58 /* Colon */ :\n                        if (fieldLength === -1) {\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    case 13 /* CarriageReturn */ :\n                        discardTrailingNewline = true;\n                    case 10 /* NewLine */ :\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1) {\n                break;\n            }\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position;\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength) {\n            buffer = void 0;\n        } else if (lineStart !== 0) {\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n    return function onLine(line, fieldLength) {\n        if (line.length === 0) {\n            onMessage?.(message);\n            message = newMessage();\n        } else if (fieldLength > 0) {\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */  ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n            switch(field){\n                case \"data\":\n                    message.data = message.data ? message.data + \"\\n\" + value : value;\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId(message.id = value);\n                    break;\n                case \"retry\":\n                    const retry = parseInt(value, 10);\n                    if (!isNaN(retry)) {\n                        onRetry(message.retry = retry);\n                    }\n                    break;\n            }\n        }\n    };\n}\nfunction concat(a, b) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\nfunction newMessage() {\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: void 0\n    };\n}\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n    const { url, info } = await makeRequestOptions({\n        ...args,\n        stream: true\n    }, options);\n    const response = await (options?.fetch ?? fetch)(url, info);\n    if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n        return yield* streamingRequest(args, {\n            ...options,\n            wait_for_model: true\n        });\n    }\n    if (!response.ok) {\n        if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n            const output = await response.json();\n            if ([\n                400,\n                422,\n                404,\n                500\n            ].includes(response.status) && options?.chatCompletion) {\n                throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n            }\n            if (output.error) {\n                throw new Error(output.error);\n            }\n        }\n        throw new Error(`Server response contains error: ${response.status}`);\n    }\n    if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n        throw new Error(`Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\"));\n    }\n    if (!response.body) {\n        return;\n    }\n    const reader = response.body.getReader();\n    let events = [];\n    const onEvent = (event)=>{\n        events.push(event);\n    };\n    const onChunk = getLines(getMessages(()=>{}, ()=>{}, onEvent));\n    try {\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) return;\n            onChunk(value);\n            for (const event of events){\n                if (event.data.length > 0) {\n                    if (event.data === \"[DONE]\") {\n                        return;\n                    }\n                    const data = JSON.parse(event.data);\n                    if (typeof data === \"object\" && data !== null && \"error\" in data) {\n                        throw new Error(data.error);\n                    }\n                    yield data;\n                }\n            }\n            events = [];\n        }\n    } finally{\n        reader.releaseLock();\n    }\n}\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n    constructor(message){\n        super(`Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`);\n        this.name = \"InferenceOutputError\";\n    }\n};\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"audio-classification\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x.label === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n    }\n    return res;\n}\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"automatic-speech-recognition\"\n    });\n    const isValidOutput = typeof res?.text === \"string\";\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected {text: string}\");\n    }\n    return res;\n}\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"text-to-speech\"\n    });\n    const isValidOutput = res && res instanceof Blob;\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Blob\");\n    }\n    return res;\n}\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"audio-to-audio\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n    }\n    return res;\n}\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"image-classification\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x.label === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n    }\n    return res;\n}\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"image-segmentation\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n    }\n    return res;\n}\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n    const res = (await request(args, {\n        ...options,\n        taskHint: \"image-to-text\"\n    }))?.[0];\n    if (typeof res?.generated_text !== \"string\") {\n        throw new InferenceOutputError(\"Expected {generated_text: string}\");\n    }\n    return res;\n}\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"object-detection\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\");\n    }\n    return res;\n}\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"text-to-image\"\n    });\n    const isValidOutput = res && res instanceof Blob;\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Blob\");\n    }\n    return res;\n}\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    } else {\n        const bin = [];\n        arr.forEach((byte)=>{\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n    let reqArgs;\n    if (!args.parameters) {\n        reqArgs = {\n            accessToken: args.accessToken,\n            model: args.model,\n            data: args.inputs\n        };\n    } else {\n        reqArgs = {\n            ...args,\n            inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n        };\n    }\n    const res = await request(reqArgs, {\n        ...options,\n        taskHint: \"image-to-image\"\n    });\n    const isValidOutput = res && res instanceof Blob;\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Blob\");\n    }\n    return res;\n}\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n    const reqArgs = {\n        ...args,\n        inputs: {\n            image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n        }\n    };\n    const res = await request(reqArgs, {\n        ...options,\n        taskHint: \"zero-shot-image-classification\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x.label === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n    }\n    return res;\n}\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n    const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n    const res = await request(args, {\n        ...options,\n        taskHint: \"feature-extraction\",\n        ...defaultTask === \"sentence-similarity\" && {\n            forceTask: \"feature-extraction\"\n        }\n    });\n    let isValidOutput = true;\n    const isNumArrayRec = (arr, maxDepth, curDepth = 0)=>{\n        if (curDepth > maxDepth) return false;\n        if (arr.every((x)=>Array.isArray(x))) {\n            return arr.every((x)=>isNumArrayRec(x, maxDepth, curDepth + 1));\n        } else {\n            return arr.every((x)=>typeof x === \"number\");\n        }\n    };\n    isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n    }\n    return res;\n}\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"fill-mask\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\");\n    }\n    return res;\n}\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"question-answering\"\n    });\n    const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n    }\n    return res;\n}\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n    const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n    const res = await request(args, {\n        ...options,\n        taskHint: \"sentence-similarity\",\n        ...defaultTask === \"feature-extraction\" && {\n            forceTask: \"sentence-similarity\"\n        }\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected number[]\");\n    }\n    return res;\n}\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"summarization\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x?.summary_text === \"string\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n    }\n    return res?.[0];\n}\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"table-question-answering\"\n    });\n    const isValidOutput = typeof res?.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every((x)=>typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every((coord)=>Array.isArray(coord) && coord.every((x)=>typeof x === \"number\"));\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\");\n    }\n    return res;\n}\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n    const res = (await request(args, {\n        ...options,\n        taskHint: \"text-classification\"\n    }))?.[0];\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x?.label === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n    }\n    return res;\n}\n// src/utils/toArray.ts\nfunction toArray(obj) {\n    if (Array.isArray(obj)) {\n        return obj;\n    }\n    return [\n        obj\n    ];\n}\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n    const res = toArray(await request(args, {\n        ...options,\n        taskHint: \"text-generation\"\n    }));\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x?.generated_text === \"string\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n    }\n    return res?.[0];\n}\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n    yield* streamingRequest(args, {\n        ...options,\n        taskHint: \"text-generation\"\n    });\n}\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n    const res = toArray(await request(args, {\n        ...options,\n        taskHint: \"token-classification\"\n    }));\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\");\n    }\n    return res;\n}\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"translation\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x?.translation_text === \"string\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n    }\n    return res?.length === 1 ? res?.[0] : res;\n}\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n    const res = toArray(await request(args, {\n        ...options,\n        taskHint: \"zero-shot-classification\"\n    }));\n    const isValidOutput = Array.isArray(res) && res.every((x)=>Array.isArray(x.labels) && x.labels.every((_label)=>typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score)=>typeof _score === \"number\") && typeof x.sequence === \"string\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n    }\n    return res;\n}\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"text-generation\",\n        chatCompletion: true\n    });\n    const isValidOutput = typeof res === \"object\" && Array.isArray(res?.choices) && typeof res?.created === \"number\" && typeof res?.id === \"string\" && typeof res?.model === \"string\" && typeof res?.system_fingerprint === \"string\" && typeof res?.usage === \"object\";\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n    }\n    return res;\n}\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n    yield* streamingRequest(args, {\n        ...options,\n        taskHint: \"text-generation\",\n        chatCompletion: true\n    });\n}\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n    const reqArgs = {\n        ...args,\n        inputs: {\n            question: args.inputs.question,\n            // convert Blob or ArrayBuffer to base64\n            image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n        }\n    };\n    const res = toArray(await request(reqArgs, {\n        ...options,\n        taskHint: \"document-question-answering\"\n    }))?.[0];\n    const isValidOutput = typeof res?.answer === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n    }\n    return res;\n}\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n    const reqArgs = {\n        ...args,\n        inputs: {\n            question: args.inputs.question,\n            // convert Blob or ArrayBuffer to base64\n            image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n        }\n    };\n    const res = (await request(reqArgs, {\n        ...options,\n        taskHint: \"visual-question-answering\"\n    }))?.[0];\n    const isValidOutput = typeof res?.answer === \"string\" && typeof res.score === \"number\";\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n    }\n    return res;\n}\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"tabular-regression\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected number[]\");\n    }\n    return res;\n}\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n    const res = await request(args, {\n        ...options,\n        taskHint: \"tabular-classification\"\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x)=>typeof x === \"number\");\n    if (!isValidOutput) {\n        throw new InferenceOutputError(\"Expected number[]\");\n    }\n    return res;\n}\n// src/HfInference.ts\nvar HfInference = class {\n    constructor(accessToken = \"\", defaultOptions = {}){\n        this.accessToken = accessToken;\n        this.defaultOptions = defaultOptions;\n        for (const [name, fn] of Object.entries(tasks_exports)){\n            Object.defineProperty(this, name, {\n                enumerable: false,\n                value: (params, options)=>// eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    fn({\n                        ...params,\n                        accessToken\n                    }, {\n                        ...defaultOptions,\n                        ...options\n                    })\n            });\n        }\n    }\n    /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */ endpoint(endpointUrl) {\n        return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n    }\n};\nvar HfInferenceEndpoint = class {\n    constructor(endpointUrl, accessToken = \"\", defaultOptions = {}){\n        accessToken;\n        defaultOptions;\n        for (const [name, fn] of Object.entries(tasks_exports)){\n            Object.defineProperty(this, name, {\n                enumerable: false,\n                value: (params, options)=>// eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    fn({\n                        ...params,\n                        accessToken,\n                        endpointUrl\n                    }, {\n                        ...defaultOptions,\n                        ...options\n                    })\n            });\n        }\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGh1Z2dpbmdmYWNlL2luZmVyZW5jZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmTCxVQUFVSSxRQUFRRSxNQUFNO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUFFRSxZQUFZO0lBQUs7QUFDL0Q7QUFFQSxxQkFBcUI7QUFDckIsSUFBSUMsZ0JBQWdCLENBQUM7QUFDckJOLFNBQVNNLGVBQWU7SUFDdEJDLHFCQUFxQixJQUFNQTtJQUMzQkMsY0FBYyxJQUFNQTtJQUNwQkMsNEJBQTRCLElBQU1BO0lBQ2xDQyxnQkFBZ0IsSUFBTUE7SUFDdEJDLHNCQUFzQixJQUFNQTtJQUM1QkMsMkJBQTJCLElBQU1BO0lBQ2pDQyxtQkFBbUIsSUFBTUE7SUFDekJDLFVBQVUsSUFBTUE7SUFDaEJDLHFCQUFxQixJQUFNQTtJQUMzQkMsbUJBQW1CLElBQU1BO0lBQ3pCQyxjQUFjLElBQU1BO0lBQ3BCQyxhQUFhLElBQU1BO0lBQ25CQyxpQkFBaUIsSUFBTUE7SUFDdkJDLG1CQUFtQixJQUFNQTtJQUN6QkMsU0FBUyxJQUFNQTtJQUNmQyxvQkFBb0IsSUFBTUE7SUFDMUJDLGtCQUFrQixJQUFNQTtJQUN4QkMsZUFBZSxJQUFNQTtJQUNyQkMsd0JBQXdCLElBQU1BO0lBQzlCQyx1QkFBdUIsSUFBTUE7SUFDN0JDLG1CQUFtQixJQUFNQTtJQUN6QkMsb0JBQW9CLElBQU1BO0lBQzFCQyxnQkFBZ0IsSUFBTUE7SUFDdEJDLHNCQUFzQixJQUFNQTtJQUM1QkMsYUFBYSxJQUFNQTtJQUNuQkMsY0FBYyxJQUFNQTtJQUNwQkMscUJBQXFCLElBQU1BO0lBQzNCQyxhQUFhLElBQU1BO0lBQ25CQyx5QkFBeUIsSUFBTUE7SUFD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LE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUVJLE1BQU07Z0JBQ2hDRSxZQUFZO2dCQUNaa0YsT0FBTyxDQUFDcUosUUFBUXpLLFVBQ2QsOERBQThEO29CQUM5RHVLLEdBQUc7d0JBQUUsR0FBR0UsTUFBTTt3QkFBRTFLO3dCQUFhMEI7b0JBQVksR0FBRzt3QkFBRSxHQUFHNkksY0FBYzt3QkFBRSxHQUFHdEssT0FBTztvQkFBQztZQUVoRjtRQUNGO0lBQ0Y7QUFDRjtBQW9DRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYWktYXBpcy8uL25vZGVfbW9kdWxlcy9AaHVnZ2luZ2ZhY2UvaW5mZXJlbmNlL2Rpc3QvaW5kZXguanM/OTMxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvdGFza3MvaW5kZXgudHNcbnZhciB0YXNrc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0YXNrc19leHBvcnRzLCB7XG4gIGF1ZGlvQ2xhc3NpZmljYXRpb246ICgpID0+IGF1ZGlvQ2xhc3NpZmljYXRpb24sXG4gIGF1ZGlvVG9BdWRpbzogKCkgPT4gYXVkaW9Ub0F1ZGlvLFxuICBhdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvbjogKCkgPT4gYXV0b21hdGljU3BlZWNoUmVjb2duaXRpb24sXG4gIGNoYXRDb21wbGV0aW9uOiAoKSA9PiBjaGF0Q29tcGxldGlvbixcbiAgY2hhdENvbXBsZXRpb25TdHJlYW06ICgpID0+IGNoYXRDb21wbGV0aW9uU3RyZWFtLFxuICBkb2N1bWVudFF1ZXN0aW9uQW5zd2VyaW5nOiAoKSA9PiBkb2N1bWVudFF1ZXN0aW9uQW5zd2VyaW5nLFxuICBmZWF0dXJlRXh0cmFjdGlvbjogKCkgPT4gZmVhdHVyZUV4dHJhY3Rpb24sXG4gIGZpbGxNYXNrOiAoKSA9PiBmaWxsTWFzayxcbiAgaW1hZ2VDbGFzc2lmaWNhdGlvbjogKCkgPT4gaW1hZ2VDbGFzc2lmaWNhdGlvbixcbiAgaW1hZ2VTZWdtZW50YXRpb246ICgpID0+IGltYWdlU2VnbWVudGF0aW9uLFxuICBpbWFnZVRvSW1hZ2U6ICgpID0+IGltYWdlVG9JbWFnZSxcbiAgaW1hZ2VUb1RleHQ6ICgpID0+IGltYWdlVG9UZXh0LFxuICBvYmplY3REZXRlY3Rpb246ICgpID0+IG9iamVjdERldGVjdGlvbixcbiAgcXVlc3Rpb25BbnN3ZXJpbmc6ICgpID0+IHF1ZXN0aW9uQW5zd2VyaW5nLFxuICByZXF1ZXN0OiAoKSA9PiByZXF1ZXN0LFxuICBzZW50ZW5jZVNpbWlsYXJpdHk6ICgpID0+IHNlbnRlbmNlU2ltaWxhcml0eSxcbiAgc3RyZWFtaW5nUmVxdWVzdDogKCkgPT4gc3RyZWFtaW5nUmVxdWVzdCxcbiAgc3VtbWFyaXphdGlvbjogKCkgPT4gc3VtbWFyaXphdGlvbixcbiAgdGFibGVRdWVzdGlvbkFuc3dlcmluZzogKCkgPT4gdGFibGVRdWVzdGlvbkFuc3dlcmluZyxcbiAgdGFidWxhckNsYXNzaWZpY2F0aW9uOiAoKSA9PiB0YWJ1bGFyQ2xhc3NpZmljYXRpb24sXG4gIHRhYnVsYXJSZWdyZXNzaW9uOiAoKSA9PiB0YWJ1bGFyUmVncmVzc2lvbixcbiAgdGV4dENsYXNzaWZpY2F0aW9uOiAoKSA9PiB0ZXh0Q2xhc3NpZmljYXRpb24sXG4gIHRleHRHZW5lcmF0aW9uOiAoKSA9PiB0ZXh0R2VuZXJhdGlvbixcbiAgdGV4dEdlbmVyYXRpb25TdHJlYW06ICgpID0+IHRleHRHZW5lcmF0aW9uU3RyZWFtLFxuICB0ZXh0VG9JbWFnZTogKCkgPT4gdGV4dFRvSW1hZ2UsXG4gIHRleHRUb1NwZWVjaDogKCkgPT4gdGV4dFRvU3BlZWNoLFxuICB0b2tlbkNsYXNzaWZpY2F0aW9uOiAoKSA9PiB0b2tlbkNsYXNzaWZpY2F0aW9uLFxuICB0cmFuc2xhdGlvbjogKCkgPT4gdHJhbnNsYXRpb24sXG4gIHZpc3VhbFF1ZXN0aW9uQW5zd2VyaW5nOiAoKSA9PiB2aXN1YWxRdWVzdGlvbkFuc3dlcmluZyxcbiAgemVyb1Nob3RDbGFzc2lmaWNhdGlvbjogKCkgPT4gemVyb1Nob3RDbGFzc2lmaWNhdGlvbixcbiAgemVyb1Nob3RJbWFnZUNsYXNzaWZpY2F0aW9uOiAoKSA9PiB6ZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb25cbn0pO1xuXG4vLyBzcmMvdXRpbHMvcGljay50c1xuZnVuY3Rpb24gcGljayhvLCBwcm9wcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICB7fSxcbiAgICAuLi5wcm9wcy5tYXAoKHByb3ApID0+IHtcbiAgICAgIGlmIChvW3Byb3BdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgW3Byb3BdOiBvW3Byb3BdIH07XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL3R5cGVkSW5jbHVkZS50c1xuZnVuY3Rpb24gdHlwZWRJbmNsdWRlKGFyciwgdikge1xuICByZXR1cm4gYXJyLmluY2x1ZGVzKHYpO1xufVxuXG4vLyBzcmMvdXRpbHMvb21pdC50c1xuZnVuY3Rpb24gb21pdChvLCBwcm9wcykge1xuICBjb25zdCBwcm9wc0FyciA9IEFycmF5LmlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBbcHJvcHNdO1xuICBjb25zdCBsZXRzS2VlcCA9IE9iamVjdC5rZXlzKG8pLmZpbHRlcigocHJvcCkgPT4gIXR5cGVkSW5jbHVkZShwcm9wc0FyciwgcHJvcCkpO1xuICByZXR1cm4gcGljayhvLCBsZXRzS2VlcCk7XG59XG5cbi8vIHNyYy9saWIvaXNVcmwudHNcbmZ1bmN0aW9uIGlzVXJsKG1vZGVsT3JVcmwpIHtcbiAgcmV0dXJuIC9eaHR0cChzPyk6Ly50ZXN0KG1vZGVsT3JVcmwpIHx8IG1vZGVsT3JVcmwuc3RhcnRzV2l0aChcIi9cIik7XG59XG5cbi8vIHNyYy9saWIvZ2V0RGVmYXVsdFRhc2sudHNcbnZhciB0YXNrQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIENBQ0hFX0RVUkFUSU9OID0gMTAgKiA2MCAqIDFlMztcbnZhciBNQVhfQ0FDSEVfSVRFTVMgPSAxZTM7XG52YXIgSEZfSFVCX1VSTCA9IFwiaHR0cHM6Ly9odWdnaW5nZmFjZS5jb1wiO1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdFRhc2sobW9kZWwsIGFjY2Vzc1Rva2VuLCBvcHRpb25zKSB7XG4gIGlmIChpc1VybChtb2RlbCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBrZXkgPSBgJHttb2RlbH06JHthY2Nlc3NUb2tlbn1gO1xuICBsZXQgY2FjaGVkVGFzayA9IHRhc2tDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGNhY2hlZFRhc2sgJiYgY2FjaGVkVGFzay5kYXRlIDwgbmV3IERhdGUoRGF0ZS5ub3coKSAtIENBQ0hFX0RVUkFUSU9OKSkge1xuICAgIHRhc2tDYWNoZS5kZWxldGUoa2V5KTtcbiAgICBjYWNoZWRUYXNrID0gdm9pZCAwO1xuICB9XG4gIGlmIChjYWNoZWRUYXNrID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBtb2RlbFRhc2sgPSBhd2FpdCAob3B0aW9ucz8uZmV0Y2ggPz8gZmV0Y2gpKGAke0hGX0hVQl9VUkx9L2FwaS9tb2RlbHMvJHttb2RlbH0/ZXhwYW5kW109cGlwZWxpbmVfdGFnYCwge1xuICAgICAgaGVhZGVyczogYWNjZXNzVG9rZW4gPyB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gIH0gOiB7fVxuICAgIH0pLnRoZW4oKHJlc3ApID0+IHJlc3AuanNvbigpKS50aGVuKChqc29uKSA9PiBqc29uLnBpcGVsaW5lX3RhZykuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgaWYgKCFtb2RlbFRhc2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYWNoZWRUYXNrID0geyB0YXNrOiBtb2RlbFRhc2ssIGRhdGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIH07XG4gICAgdGFza0NhY2hlLnNldChrZXksIHsgdGFzazogbW9kZWxUYXNrLCBkYXRlOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSB9KTtcbiAgICBpZiAodGFza0NhY2hlLnNpemUgPiBNQVhfQ0FDSEVfSVRFTVMpIHtcbiAgICAgIHRhc2tDYWNoZS5kZWxldGUodGFza0NhY2hlLmtleXMoKS5uZXh0KCkudmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FjaGVkVGFzay50YXNrO1xufVxuXG4vLyBzcmMvbGliL21ha2VSZXF1ZXN0T3B0aW9ucy50c1xudmFyIEhGX0lORkVSRU5DRV9BUElfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLWluZmVyZW5jZS5odWdnaW5nZmFjZS5jb1wiO1xudmFyIHRhc2tzID0gbnVsbDtcbmFzeW5jIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0T3B0aW9ucyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYWNjZXNzVG9rZW4sIGVuZHBvaW50VXJsLCAuLi5vdGhlckFyZ3MgfSA9IGFyZ3M7XG4gIGxldCB7IG1vZGVsIH0gPSBhcmdzO1xuICBjb25zdCB7XG4gICAgZm9yY2VUYXNrOiB0YXNrLFxuICAgIGluY2x1ZGVDcmVkZW50aWFscyxcbiAgICB0YXNrSGludCxcbiAgICB3YWl0X2Zvcl9tb2RlbCxcbiAgICB1c2VfY2FjaGUsXG4gICAgZG9udF9sb2FkX21vZGVsLFxuICAgIGNoYXRDb21wbGV0aW9uOiBjaGF0Q29tcGxldGlvbjJcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7YWNjZXNzVG9rZW59YDtcbiAgfVxuICBpZiAoIW1vZGVsICYmICF0YXNrcyAmJiB0YXNrSGludCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0hGX0hVQl9VUkx9L2FwaS90YXNrc2ApO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIHRhc2tzID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFtb2RlbCAmJiB0YXNrcyAmJiB0YXNrSGludCkge1xuICAgIGNvbnN0IHRhc2tJbmZvID0gdGFza3NbdGFza0hpbnRdO1xuICAgIGlmICh0YXNrSW5mbykge1xuICAgICAgbW9kZWwgPSB0YXNrSW5mby5tb2RlbHNbMF0uaWQ7XG4gICAgfVxuICB9XG4gIGlmICghbW9kZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2RlbCBwcm92aWRlZCwgYW5kIG5vIGRlZmF1bHQgbW9kZWwgZm91bmQgZm9yIHRoaXMgdGFza1wiKTtcbiAgfVxuICBjb25zdCBiaW5hcnkgPSBcImRhdGFcIiBpbiBhcmdzICYmICEhYXJncy5kYXRhO1xuICBpZiAoIWJpbmFyeSkge1xuICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgfVxuICBpZiAod2FpdF9mb3JfbW9kZWwpIHtcbiAgICBoZWFkZXJzW1wiWC1XYWl0LUZvci1Nb2RlbFwiXSA9IFwidHJ1ZVwiO1xuICB9XG4gIGlmICh1c2VfY2FjaGUgPT09IGZhbHNlKSB7XG4gICAgaGVhZGVyc1tcIlgtVXNlLUNhY2hlXCJdID0gXCJmYWxzZVwiO1xuICB9XG4gIGlmIChkb250X2xvYWRfbW9kZWwpIHtcbiAgICBoZWFkZXJzW1wiWC1Mb2FkLU1vZGVsXCJdID0gXCIwXCI7XG4gIH1cbiAgbGV0IHVybCA9ICgoKSA9PiB7XG4gICAgaWYgKGVuZHBvaW50VXJsICYmIGlzVXJsKG1vZGVsKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJvdGggbW9kZWwgYW5kIGVuZHBvaW50VXJsIGNhbm5vdCBiZSBVUkxzXCIpO1xuICAgIH1cbiAgICBpZiAoaXNVcmwobW9kZWwpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVc2luZyBhIG1vZGVsIFVSTCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoZSBgZW5kcG9pbnRVcmxgIHBhcmFtZXRlciBpbnN0ZWFkXCIpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH1cbiAgICBpZiAoZW5kcG9pbnRVcmwpIHtcbiAgICAgIHJldHVybiBlbmRwb2ludFVybDtcbiAgICB9XG4gICAgaWYgKHRhc2spIHtcbiAgICAgIHJldHVybiBgJHtIRl9JTkZFUkVOQ0VfQVBJX0JBU0VfVVJMfS9waXBlbGluZS8ke3Rhc2t9LyR7bW9kZWx9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke0hGX0lORkVSRU5DRV9BUElfQkFTRV9VUkx9L21vZGVscy8ke21vZGVsfWA7XG4gIH0pKCk7XG4gIGlmIChjaGF0Q29tcGxldGlvbjIgJiYgIXVybC5lbmRzV2l0aChcIi9jaGF0L2NvbXBsZXRpb25zXCIpKSB7XG4gICAgdXJsICs9IFwiL3YxL2NoYXQvY29tcGxldGlvbnNcIjtcbiAgfVxuICBsZXQgY3JlZGVudGlhbHM7XG4gIGlmICh0eXBlb2YgaW5jbHVkZUNyZWRlbnRpYWxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgY3JlZGVudGlhbHMgPSBpbmNsdWRlQ3JlZGVudGlhbHM7XG4gIH0gZWxzZSBpZiAoaW5jbHVkZUNyZWRlbnRpYWxzID09PSB0cnVlKSB7XG4gICAgY3JlZGVudGlhbHMgPSBcImluY2x1ZGVcIjtcbiAgfVxuICBjb25zdCBpbmZvID0ge1xuICAgIGhlYWRlcnMsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBiaW5hcnkgPyBhcmdzLmRhdGEgOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAuLi5vdGhlckFyZ3MubW9kZWwgJiYgaXNVcmwob3RoZXJBcmdzLm1vZGVsKSA/IG9taXQob3RoZXJBcmdzLCBcIm1vZGVsXCIpIDogb3RoZXJBcmdzXG4gICAgfSksXG4gICAgLi4uY3JlZGVudGlhbHMgJiYgeyBjcmVkZW50aWFscyB9LFxuICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsXG4gIH07XG4gIHJldHVybiB7IHVybCwgaW5mbyB9O1xufVxuXG4vLyBzcmMvdGFza3MvY3VzdG9tL3JlcXVlc3QudHNcbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3QoYXJncywgb3B0aW9ucykge1xuICBjb25zdCB7IHVybCwgaW5mbyB9ID0gYXdhaXQgbWFrZVJlcXVlc3RPcHRpb25zKGFyZ3MsIG9wdGlvbnMpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChvcHRpb25zPy5mZXRjaCA/PyBmZXRjaCkodXJsLCBpbmZvKTtcbiAgaWYgKG9wdGlvbnM/LnJldHJ5X29uX2Vycm9yICE9PSBmYWxzZSAmJiByZXNwb25zZS5zdGF0dXMgPT09IDUwMyAmJiAhb3B0aW9ucz8ud2FpdF9mb3JfbW9kZWwpIHtcbiAgICByZXR1cm4gcmVxdWVzdChhcmdzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgd2FpdF9mb3JfbW9kZWw6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPy5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgaWYgKFs0MDAsIDQyMiwgNDA0LCA1MDBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykgJiYgb3B0aW9ucz8uY2hhdENvbXBsZXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgJHthcmdzLm1vZGVsfSBkb2VzIG5vdCBzZWVtIHRvIHN1cHBvcnQgY2hhdCBjb21wbGV0aW9uLiBFcnJvcjogJHtvdXRwdXQuZXJyb3J9YCk7XG4gICAgICB9XG4gICAgICBpZiAob3V0cHV0LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShvdXRwdXQuZXJyb3IpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgdGhlIGJsb2JcIik7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPy5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbn1cblxuLy8gc3JjL3ZlbmRvci9mZXRjaC1ldmVudC1zb3VyY2UvcGFyc2UudHNcbmZ1bmN0aW9uIGdldExpbmVzKG9uTGluZSkge1xuICBsZXQgYnVmZmVyO1xuICBsZXQgcG9zaXRpb247XG4gIGxldCBmaWVsZExlbmd0aDtcbiAgbGV0IGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uQ2h1bmsoYXJyKSB7XG4gICAgaWYgKGJ1ZmZlciA9PT0gdm9pZCAwKSB7XG4gICAgICBidWZmZXIgPSBhcnI7XG4gICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICBmaWVsZExlbmd0aCA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBjb25jYXQoYnVmZmVyLCBhcnIpO1xuICAgIH1cbiAgICBjb25zdCBidWZMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIGxldCBsaW5lU3RhcnQgPSAwO1xuICAgIHdoaWxlIChwb3NpdGlvbiA8IGJ1Zkxlbmd0aCkge1xuICAgICAgaWYgKGRpc2NhcmRUcmFpbGluZ05ld2xpbmUpIHtcbiAgICAgICAgaWYgKGJ1ZmZlcltwb3NpdGlvbl0gPT09IDEwIC8qIE5ld0xpbmUgKi8pIHtcbiAgICAgICAgICBsaW5lU3RhcnQgPSArK3Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lRW5kID0gLTE7XG4gICAgICBmb3IgKDsgcG9zaXRpb24gPCBidWZMZW5ndGggJiYgbGluZUVuZCA9PT0gLTE7ICsrcG9zaXRpb24pIHtcbiAgICAgICAgc3dpdGNoIChidWZmZXJbcG9zaXRpb25dKSB7XG4gICAgICAgICAgY2FzZSA1OCAvKiBDb2xvbiAqLzpcbiAgICAgICAgICAgIGlmIChmaWVsZExlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZmllbGRMZW5ndGggPSBwb3NpdGlvbiAtIGxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTMgLyogQ2FycmlhZ2VSZXR1cm4gKi86XG4gICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICBjYXNlIDEwIC8qIE5ld0xpbmUgKi86XG4gICAgICAgICAgICBsaW5lRW5kID0gcG9zaXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmVFbmQgPT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb25MaW5lKGJ1ZmZlci5zdWJhcnJheShsaW5lU3RhcnQsIGxpbmVFbmQpLCBmaWVsZExlbmd0aCk7XG4gICAgICBsaW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICAgIGZpZWxkTGVuZ3RoID0gLTE7XG4gICAgfVxuICAgIGlmIChsaW5lU3RhcnQgPT09IGJ1Zkxlbmd0aCkge1xuICAgICAgYnVmZmVyID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAobGluZVN0YXJ0ICE9PSAwKSB7XG4gICAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkobGluZVN0YXJ0KTtcbiAgICAgIHBvc2l0aW9uIC09IGxpbmVTdGFydDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlcyhvbklkLCBvblJldHJ5LCBvbk1lc3NhZ2UpIHtcbiAgbGV0IG1lc3NhZ2UgPSBuZXdNZXNzYWdlKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uTGluZShsaW5lLCBmaWVsZExlbmd0aCkge1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb25NZXNzYWdlPy4obWVzc2FnZSk7XG4gICAgICBtZXNzYWdlID0gbmV3TWVzc2FnZSgpO1xuICAgIH0gZWxzZSBpZiAoZmllbGRMZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGRlY29kZXIuZGVjb2RlKGxpbmUuc3ViYXJyYXkoMCwgZmllbGRMZW5ndGgpKTtcbiAgICAgIGNvbnN0IHZhbHVlT2Zmc2V0ID0gZmllbGRMZW5ndGggKyAobGluZVtmaWVsZExlbmd0aCArIDFdID09PSAzMiAvKiBTcGFjZSAqLyA/IDIgOiAxKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobGluZS5zdWJhcnJheSh2YWx1ZU9mZnNldCkpO1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IG1lc3NhZ2UuZGF0YSA/IG1lc3NhZ2UuZGF0YSArIFwiXFxuXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIG9uSWQobWVzc2FnZS5pZCA9IHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgICAgY29uc3QgcmV0cnkgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgIGlmICghaXNOYU4ocmV0cnkpKSB7XG4gICAgICAgICAgICBvblJldHJ5KG1lc3NhZ2UucmV0cnkgPSByZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICByZXMuc2V0KGEpO1xuICByZXMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5ld01lc3NhZ2UoKSB7XG4gIHJldHVybiB7XG4gICAgZGF0YTogXCJcIixcbiAgICBldmVudDogXCJcIixcbiAgICBpZDogXCJcIixcbiAgICByZXRyeTogdm9pZCAwXG4gIH07XG59XG5cbi8vIHNyYy90YXNrcy9jdXN0b20vc3RyZWFtaW5nUmVxdWVzdC50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWluZ1JlcXVlc3QoYXJncywgb3B0aW9ucykge1xuICBjb25zdCB7IHVybCwgaW5mbyB9ID0gYXdhaXQgbWFrZVJlcXVlc3RPcHRpb25zKHsgLi4uYXJncywgc3RyZWFtOiB0cnVlIH0sIG9wdGlvbnMpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChvcHRpb25zPy5mZXRjaCA/PyBmZXRjaCkodXJsLCBpbmZvKTtcbiAgaWYgKG9wdGlvbnM/LnJldHJ5X29uX2Vycm9yICE9PSBmYWxzZSAmJiByZXNwb25zZS5zdGF0dXMgPT09IDUwMyAmJiAhb3B0aW9ucz8ud2FpdF9mb3JfbW9kZWwpIHtcbiAgICByZXR1cm4geWllbGQqIHN0cmVhbWluZ1JlcXVlc3QoYXJncywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHdhaXRfZm9yX21vZGVsOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKT8uc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGlmIChbNDAwLCA0MjIsIDQwNCwgNTAwXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpICYmIG9wdGlvbnM/LmNoYXRDb21wbGV0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyICR7YXJncy5tb2RlbH0gZG9lcyBub3Qgc2VlbSB0byBzdXBwb3J0IGNoYXQgY29tcGxldGlvbi4gRXJyb3I6ICR7b3V0cHV0LmVycm9yfWApO1xuICAgICAgfVxuICAgICAgaWYgKG91dHB1dC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3V0cHV0LmVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmVzcG9uc2UgY29udGFpbnMgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LnN0YXJ0c1dpdGgoXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBldmVudCBzdHJlYW0gY29udGVudCB0eXBlLCBpdCByZXR1cm5lZCBgICsgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIilcbiAgICApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBsZXQgZXZlbnRzID0gW107XG4gIGNvbnN0IG9uRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudHMucHVzaChldmVudCk7XG4gIH07XG4gIGNvbnN0IG9uQ2h1bmsgPSBnZXRMaW5lcyhcbiAgICBnZXRNZXNzYWdlcyhcbiAgICAgICgpID0+IHtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgb25FdmVudFxuICAgIClcbiAgKTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICByZXR1cm47XG4gICAgICBvbkNodW5rKHZhbHVlKTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCAmJiBcImVycm9yXCIgaW4gZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCBkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudHMgPSBbXTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9JbmZlcmVuY2VPdXRwdXRFcnJvci50c1xudmFyIEluZmVyZW5jZU91dHB1dEVycm9yID0gY2xhc3MgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBpbmZlcmVuY2Ugb3V0cHV0OiAke21lc3NhZ2V9LiBVc2UgdGhlICdyZXF1ZXN0JyBtZXRob2Qgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRvIGRvIGEgY3VzdG9tIGNhbGwgd2l0aCBubyB0eXBlIGNoZWNraW5nLmBcbiAgICApO1xuICAgIHRoaXMubmFtZSA9IFwiSW5mZXJlbmNlT3V0cHV0RXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL3Rhc2tzL2F1ZGlvL2F1ZGlvQ2xhc3NpZmljYXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGF1ZGlvQ2xhc3NpZmljYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImF1ZGlvLWNsYXNzaWZpY2F0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeC5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2F1ZGlvL2F1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBhdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiYXV0b21hdGljLXNwZWVjaC1yZWNvZ25pdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gdHlwZW9mIHJlcz8udGV4dCA9PT0gXCJzdHJpbmdcIjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQge3RleHQ6IHN0cmluZ31cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2F1ZGlvL3RleHRUb1NwZWVjaC50c1xuYXN5bmMgZnVuY3Rpb24gdGV4dFRvU3BlZWNoKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LXRvLXNwZWVjaFwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gcmVzICYmIHJlcyBpbnN0YW5jZW9mIEJsb2I7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEJsb2JcIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2F1ZGlvL2F1ZGlvVG9BdWRpby50c1xuYXN5bmMgZnVuY3Rpb24gYXVkaW9Ub0F1ZGlvKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJhdWRpby10by1hdWRpb1wiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeShcbiAgICAoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguYmxvYiA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeFtcImNvbnRlbnQtdHlwZVwiXSA9PT0gXCJzdHJpbmdcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6IHN0cmluZywgYmxvYjogc3RyaW5nLCBjb250ZW50LXR5cGU6IHN0cmluZ30+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9jdi9pbWFnZUNsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBpbWFnZUNsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJpbWFnZS1jbGFzc2lmaWNhdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6IHN0cmluZywgc2NvcmU6IG51bWJlcn0+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9jdi9pbWFnZVNlZ21lbnRhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gaW1hZ2VTZWdtZW50YXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImltYWdlLXNlZ21lbnRhdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHgubWFzayA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDogc3RyaW5nLCBtYXNrOiBzdHJpbmcsIHNjb3JlOiBudW1iZXJ9PlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvY3YvaW1hZ2VUb1RleHQudHNcbmFzeW5jIGZ1bmN0aW9uIGltYWdlVG9UZXh0KGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gKGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiaW1hZ2UtdG8tdGV4dFwiXG4gIH0pKT8uWzBdO1xuICBpZiAodHlwZW9mIHJlcz8uZ2VuZXJhdGVkX3RleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCB7Z2VuZXJhdGVkX3RleHQ6IHN0cmluZ31cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2N2L29iamVjdERldGVjdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gb2JqZWN0RGV0ZWN0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJvYmplY3QtZGV0ZWN0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KFxuICAgICh4KSA9PiB0eXBlb2YgeC5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5ib3gueG1pbiA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5ib3gueW1pbiA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5ib3gueG1heCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5ib3gueW1heCA9PT0gXCJudW1iZXJcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDpzdHJpbmc7IHNjb3JlOm51bWJlcjsgYm94Ont4bWluOm51bWJlcjsgeW1pbjpudW1iZXI7IHhtYXg6bnVtYmVyOyB5bWF4Om51bWJlcn19PlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvY3YvdGV4dFRvSW1hZ2UudHNcbmFzeW5jIGZ1bmN0aW9uIHRleHRUb0ltYWdlKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LXRvLWltYWdlXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSByZXMgJiYgcmVzIGluc3RhbmNlb2YgQmxvYjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQmxvYlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdXRpbHMvYmFzZTY0RnJvbUJ5dGVzLnRzXG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYmluID0gW107XG4gICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICB9XG59XG5cbi8vIHNyYy90YXNrcy9jdi9pbWFnZVRvSW1hZ2UudHNcbmFzeW5jIGZ1bmN0aW9uIGltYWdlVG9JbWFnZShhcmdzLCBvcHRpb25zKSB7XG4gIGxldCByZXFBcmdzO1xuICBpZiAoIWFyZ3MucGFyYW1ldGVycykge1xuICAgIHJlcUFyZ3MgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogYXJncy5hY2Nlc3NUb2tlbixcbiAgICAgIG1vZGVsOiBhcmdzLm1vZGVsLFxuICAgICAgZGF0YTogYXJncy5pbnB1dHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJlcUFyZ3MgPSB7XG4gICAgICAuLi5hcmdzLFxuICAgICAgaW5wdXRzOiBiYXNlNjRGcm9tQnl0ZXMoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGFyZ3MuaW5wdXRzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBhcmdzLmlucHV0cyA6IGF3YWl0IGFyZ3MuaW5wdXRzLmFycmF5QnVmZmVyKCkpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KHJlcUFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImltYWdlLXRvLWltYWdlXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSByZXMgJiYgcmVzIGluc3RhbmNlb2YgQmxvYjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQmxvYlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvY3YvemVyb1Nob3RJbWFnZUNsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB6ZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXFBcmdzID0ge1xuICAgIC4uLmFyZ3MsXG4gICAgaW5wdXRzOiB7XG4gICAgICBpbWFnZTogYmFzZTY0RnJvbUJ5dGVzKFxuICAgICAgICBuZXcgVWludDhBcnJheShcbiAgICAgICAgICBhcmdzLmlucHV0cy5pbWFnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gYXJncy5pbnB1dHMuaW1hZ2UgOiBhd2FpdCBhcmdzLmlucHV0cy5pbWFnZS5hcnJheUJ1ZmZlcigpXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QocmVxQXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiemVyby1zaG90LWltYWdlLWNsYXNzaWZpY2F0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeC5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC9mZWF0dXJlRXh0cmFjdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gZmVhdHVyZUV4dHJhY3Rpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0VGFzayA9IGFyZ3MubW9kZWwgPyBhd2FpdCBnZXREZWZhdWx0VGFzayhhcmdzLm1vZGVsLCBhcmdzLmFjY2Vzc1Rva2VuLCBvcHRpb25zKSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJmZWF0dXJlLWV4dHJhY3Rpb25cIixcbiAgICAuLi5kZWZhdWx0VGFzayA9PT0gXCJzZW50ZW5jZS1zaW1pbGFyaXR5XCIgJiYgeyBmb3JjZVRhc2s6IFwiZmVhdHVyZS1leHRyYWN0aW9uXCIgfVxuICB9KTtcbiAgbGV0IGlzVmFsaWRPdXRwdXQgPSB0cnVlO1xuICBjb25zdCBpc051bUFycmF5UmVjID0gKGFyciwgbWF4RGVwdGgsIGN1ckRlcHRoID0gMCkgPT4ge1xuICAgIGlmIChjdXJEZXB0aCA+IG1heERlcHRoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcnIuZXZlcnkoKHgpID0+IEFycmF5LmlzQXJyYXkoeCkpKSB7XG4gICAgICByZXR1cm4gYXJyLmV2ZXJ5KCh4KSA9PiBpc051bUFycmF5UmVjKHgsIG1heERlcHRoLCBjdXJEZXB0aCArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyci5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIpO1xuICAgIH1cbiAgfTtcbiAgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiBpc051bUFycmF5UmVjKHJlcywgMywgMCk7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PG51bWJlcltdW11bXSB8IG51bWJlcltdW10gfCBudW1iZXJbXSB8IG51bWJlcj5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC9maWxsTWFzay50c1xuYXN5bmMgZnVuY3Rpb24gZmlsbE1hc2soYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImZpbGwtbWFza1wiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeShcbiAgICAoeCkgPT4gdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguc2VxdWVuY2UgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHgudG9rZW4gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHgudG9rZW5fc3RyID09PSBcInN0cmluZ1wiXG4gICk7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgQXJyYXk8e3Njb3JlOiBudW1iZXIsIHNlcXVlbmNlOiBzdHJpbmcsIHRva2VuOiBudW1iZXIsIHRva2VuX3N0cjogc3RyaW5nfT5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC9xdWVzdGlvbkFuc3dlcmluZy50c1xuYXN5bmMgZnVuY3Rpb24gcXVlc3Rpb25BbnN3ZXJpbmcoYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcInF1ZXN0aW9uLWFuc3dlcmluZ1wiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gdHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIiAmJiAhIXJlcyAmJiB0eXBlb2YgcmVzLmFuc3dlciA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmVzLmVuZCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcmVzLnNjb3JlID09PSBcIm51bWJlclwiICYmIHR5cGVvZiByZXMuc3RhcnQgPT09IFwibnVtYmVyXCI7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIHthbnN3ZXI6IHN0cmluZywgZW5kOiBudW1iZXIsIHNjb3JlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXJ9XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvc2VudGVuY2VTaW1pbGFyaXR5LnRzXG5hc3luYyBmdW5jdGlvbiBzZW50ZW5jZVNpbWlsYXJpdHkoYXJncywgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0VGFzayA9IGFyZ3MubW9kZWwgPyBhd2FpdCBnZXREZWZhdWx0VGFzayhhcmdzLm1vZGVsLCBhcmdzLmFjY2Vzc1Rva2VuLCBvcHRpb25zKSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJzZW50ZW5jZS1zaW1pbGFyaXR5XCIsXG4gICAgLi4uZGVmYXVsdFRhc2sgPT09IFwiZmVhdHVyZS1leHRyYWN0aW9uXCIgJiYgeyBmb3JjZVRhc2s6IFwic2VudGVuY2Utc2ltaWxhcml0eVwiIH1cbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIG51bWJlcltdXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvc3VtbWFyaXphdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gc3VtbWFyaXphdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwic3VtbWFyaXphdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHg/LnN1bW1hcnlfdGV4dCA9PT0gXCJzdHJpbmdcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtzdW1tYXJ5X3RleHQ6IHN0cmluZ30+XCIpO1xuICB9XG4gIHJldHVybiByZXM/LlswXTtcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90YWJsZVF1ZXN0aW9uQW5zd2VyaW5nLnRzXG5hc3luYyBmdW5jdGlvbiB0YWJsZVF1ZXN0aW9uQW5zd2VyaW5nKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0YWJsZS1xdWVzdGlvbi1hbnN3ZXJpbmdcIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHR5cGVvZiByZXM/LmFnZ3JlZ2F0b3IgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcy5hbnN3ZXIgPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShyZXMuY2VsbHMpICYmIHJlcy5jZWxscy5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09IFwic3RyaW5nXCIpICYmIEFycmF5LmlzQXJyYXkocmVzLmNvb3JkaW5hdGVzKSAmJiByZXMuY29vcmRpbmF0ZXMuZXZlcnkoKGNvb3JkKSA9PiBBcnJheS5pc0FycmF5KGNvb3JkKSAmJiBjb29yZC5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIpKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFxuICAgICAgXCJFeHBlY3RlZCB7YWdncmVnYXRvcjogc3RyaW5nLCBhbnN3ZXI6IHN0cmluZywgY2VsbHM6IHN0cmluZ1tdLCBjb29yZGluYXRlczogbnVtYmVyW11bXX1cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90ZXh0Q2xhc3NpZmljYXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHRleHRDbGFzc2lmaWNhdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IChhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcInRleHQtY2xhc3NpZmljYXRpb25cIlxuICB9KSk/LlswXTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4Py5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3V0aWxzL3RvQXJyYXkudHNcbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJldHVybiBbb2JqXTtcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90ZXh0R2VuZXJhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gdGV4dEdlbmVyYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSB0b0FycmF5KFxuICAgIGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRhc2tIaW50OiBcInRleHQtZ2VuZXJhdGlvblwiXG4gICAgfSlcbiAgKTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4Py5nZW5lcmF0ZWRfdGV4dCA9PT0gXCJzdHJpbmdcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtnZW5lcmF0ZWRfdGV4dDogc3RyaW5nfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcz8uWzBdO1xufVxuXG4vLyBzcmMvdGFza3MvbmxwL3RleHRHZW5lcmF0aW9uU3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogdGV4dEdlbmVyYXRpb25TdHJlYW0oYXJncywgb3B0aW9ucykge1xuICB5aWVsZCogc3RyZWFtaW5nUmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LWdlbmVyYXRpb25cIlxuICB9KTtcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90b2tlbkNsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB0b2tlbkNsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gdG9BcnJheShcbiAgICBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXNrSGludDogXCJ0b2tlbi1jbGFzc2lmaWNhdGlvblwiXG4gICAgfSlcbiAgKTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoXG4gICAgKHgpID0+IHR5cGVvZiB4LmVuZCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5lbnRpdHlfZ3JvdXAgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguc3RhcnQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHgud29yZCA9PT0gXCJzdHJpbmdcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIEFycmF5PHtlbmQ6IG51bWJlciwgZW50aXR5X2dyb3VwOiBzdHJpbmcsIHNjb3JlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIHdvcmQ6IHN0cmluZ30+XCJcbiAgICApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvdHJhbnNsYXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHRyYW5zbGF0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0cmFuc2xhdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHg/LnRyYW5zbGF0aW9uX3RleHQgPT09IFwic3RyaW5nXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCB0eXBlIEFycmF5PHt0cmFuc2xhdGlvbl90ZXh0OiBzdHJpbmd9PlwiKTtcbiAgfVxuICByZXR1cm4gcmVzPy5sZW5ndGggPT09IDEgPyByZXM/LlswXSA6IHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC96ZXJvU2hvdENsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB6ZXJvU2hvdENsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gdG9BcnJheShcbiAgICBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXNrSGludDogXCJ6ZXJvLXNob3QtY2xhc3NpZmljYXRpb25cIlxuICAgIH0pXG4gICk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KFxuICAgICh4KSA9PiBBcnJheS5pc0FycmF5KHgubGFiZWxzKSAmJiB4LmxhYmVscy5ldmVyeSgoX2xhYmVsKSA9PiB0eXBlb2YgX2xhYmVsID09PSBcInN0cmluZ1wiKSAmJiBBcnJheS5pc0FycmF5KHguc2NvcmVzKSAmJiB4LnNjb3Jlcy5ldmVyeSgoX3Njb3JlKSA9PiB0eXBlb2YgX3Njb3JlID09PSBcIm51bWJlclwiKSAmJiB0eXBlb2YgeC5zZXF1ZW5jZSA9PT0gXCJzdHJpbmdcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWxzOiBzdHJpbmdbXSwgc2NvcmVzOiBudW1iZXJbXSwgc2VxdWVuY2U6IHN0cmluZ30+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvY2hhdENvbXBsZXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGNoYXRDb21wbGV0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LWdlbmVyYXRpb25cIixcbiAgICBjaGF0Q29tcGxldGlvbjogdHJ1ZVxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHR5cGVvZiByZXMgPT09IFwib2JqZWN0XCIgJiYgQXJyYXkuaXNBcnJheShyZXM/LmNob2ljZXMpICYmIHR5cGVvZiByZXM/LmNyZWF0ZWQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHJlcz8uaWQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcz8ubW9kZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcz8uc3lzdGVtX2ZpbmdlcnByaW50ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByZXM/LnVzYWdlID09PSBcIm9iamVjdFwiO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBDaGF0Q29tcGxldGlvbk91dHB1dFwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvbmxwL2NoYXRDb21wbGV0aW9uU3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogY2hhdENvbXBsZXRpb25TdHJlYW0oYXJncywgb3B0aW9ucykge1xuICB5aWVsZCogc3RyZWFtaW5nUmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LWdlbmVyYXRpb25cIixcbiAgICBjaGF0Q29tcGxldGlvbjogdHJ1ZVxuICB9KTtcbn1cblxuLy8gc3JjL3Rhc2tzL211bHRpbW9kYWwvZG9jdW1lbnRRdWVzdGlvbkFuc3dlcmluZy50c1xuYXN5bmMgZnVuY3Rpb24gZG9jdW1lbnRRdWVzdGlvbkFuc3dlcmluZyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcUFyZ3MgPSB7XG4gICAgLi4uYXJncyxcbiAgICBpbnB1dHM6IHtcbiAgICAgIHF1ZXN0aW9uOiBhcmdzLmlucHV0cy5xdWVzdGlvbixcbiAgICAgIC8vIGNvbnZlcnQgQmxvYiBvciBBcnJheUJ1ZmZlciB0byBiYXNlNjRcbiAgICAgIGltYWdlOiBiYXNlNjRGcm9tQnl0ZXMoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgIGFyZ3MuaW5wdXRzLmltYWdlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBhcmdzLmlucHV0cy5pbWFnZSA6IGF3YWl0IGFyZ3MuaW5wdXRzLmltYWdlLmFycmF5QnVmZmVyKClcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVzID0gdG9BcnJheShcbiAgICBhd2FpdCByZXF1ZXN0KHJlcUFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXNrSGludDogXCJkb2N1bWVudC1xdWVzdGlvbi1hbnN3ZXJpbmdcIlxuICAgIH0pXG4gICk/LlswXTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHR5cGVvZiByZXM/LmFuc3dlciA9PT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIHJlcy5lbmQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHJlcy5lbmQgPT09IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2YgcmVzLnNjb3JlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiByZXMuc2NvcmUgPT09IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2YgcmVzLnN0YXJ0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiByZXMuc3RhcnQgPT09IFwidW5kZWZpbmVkXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7YW5zd2VyOiBzdHJpbmcsIGVuZD86IG51bWJlciwgc2NvcmU/OiBudW1iZXIsIHN0YXJ0PzogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL211bHRpbW9kYWwvdmlzdWFsUXVlc3Rpb25BbnN3ZXJpbmcudHNcbmFzeW5jIGZ1bmN0aW9uIHZpc3VhbFF1ZXN0aW9uQW5zd2VyaW5nKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVxQXJncyA9IHtcbiAgICAuLi5hcmdzLFxuICAgIGlucHV0czoge1xuICAgICAgcXVlc3Rpb246IGFyZ3MuaW5wdXRzLnF1ZXN0aW9uLFxuICAgICAgLy8gY29udmVydCBCbG9iIG9yIEFycmF5QnVmZmVyIHRvIGJhc2U2NFxuICAgICAgaW1hZ2U6IGJhc2U2NEZyb21CeXRlcyhcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgYXJncy5pbnB1dHMuaW1hZ2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGFyZ3MuaW5wdXRzLmltYWdlIDogYXdhaXQgYXJncy5pbnB1dHMuaW1hZ2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9O1xuICBjb25zdCByZXMgPSAoYXdhaXQgcmVxdWVzdChyZXFBcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ2aXN1YWwtcXVlc3Rpb24tYW5zd2VyaW5nXCJcbiAgfSkpPy5bMF07XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSB0eXBlb2YgcmVzPy5hbnN3ZXIgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcy5zY29yZSA9PT0gXCJudW1iZXJcIjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQXJyYXk8e2Fuc3dlcjogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL3RhYnVsYXIvdGFidWxhclJlZ3Jlc3Npb24udHNcbmFzeW5jIGZ1bmN0aW9uIHRhYnVsYXJSZWdyZXNzaW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0YWJ1bGFyLXJlZ3Jlc3Npb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSBcIm51bWJlclwiKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgbnVtYmVyW11cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL3RhYnVsYXIvdGFidWxhckNsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB0YWJ1bGFyQ2xhc3NpZmljYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcInRhYnVsYXItY2xhc3NpZmljYXRpb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSBcIm51bWJlclwiKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgbnVtYmVyW11cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL0hmSW5mZXJlbmNlLnRzXG52YXIgSGZJbmZlcmVuY2UgPSBjbGFzcyB7XG4gIGFjY2Vzc1Rva2VuO1xuICBkZWZhdWx0T3B0aW9ucztcbiAgY29uc3RydWN0b3IoYWNjZXNzVG9rZW4gPSBcIlwiLCBkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBmbl0gb2YgT2JqZWN0LmVudHJpZXModGFza3NfZXhwb3J0cykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogKHBhcmFtcywgb3B0aW9ucykgPT4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgZm4oeyAuLi5wYXJhbXMsIGFjY2Vzc1Rva2VuIH0sIHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfSlcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvcHkgb2YgSGZJbmZlcmVuY2UgdGllZCB0byBhIHNwZWNpZmllZCBlbmRwb2ludC5cbiAgICovXG4gIGVuZHBvaW50KGVuZHBvaW50VXJsKSB7XG4gICAgcmV0dXJuIG5ldyBIZkluZmVyZW5jZUVuZHBvaW50KGVuZHBvaW50VXJsLCB0aGlzLmFjY2Vzc1Rva2VuLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxufTtcbnZhciBIZkluZmVyZW5jZUVuZHBvaW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbmRwb2ludFVybCwgYWNjZXNzVG9rZW4gPSBcIlwiLCBkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgYWNjZXNzVG9rZW47XG4gICAgZGVmYXVsdE9wdGlvbnM7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgZm5dIG9mIE9iamVjdC5lbnRyaWVzKHRhc2tzX2V4cG9ydHMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IChwYXJhbXMsIG9wdGlvbnMpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIGZuKHsgLi4ucGFyYW1zLCBhY2Nlc3NUb2tlbiwgZW5kcG9pbnRVcmwgfSwgeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9KVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5leHBvcnQge1xuICBIZkluZmVyZW5jZSxcbiAgSGZJbmZlcmVuY2VFbmRwb2ludCxcbiAgSW5mZXJlbmNlT3V0cHV0RXJyb3IsXG4gIGF1ZGlvQ2xhc3NpZmljYXRpb24sXG4gIGF1ZGlvVG9BdWRpbyxcbiAgYXV0b21hdGljU3BlZWNoUmVjb2duaXRpb24sXG4gIGNoYXRDb21wbGV0aW9uLFxuICBjaGF0Q29tcGxldGlvblN0cmVhbSxcbiAgZG9jdW1lbnRRdWVzdGlvbkFuc3dlcmluZyxcbiAgZmVhdHVyZUV4dHJhY3Rpb24sXG4gIGZpbGxNYXNrLFxuICBpbWFnZUNsYXNzaWZpY2F0aW9uLFxuICBpbWFnZVNlZ21lbnRhdGlvbixcbiAgaW1hZ2VUb0ltYWdlLFxuICBpbWFnZVRvVGV4dCxcbiAgb2JqZWN0RGV0ZWN0aW9uLFxuICBxdWVzdGlvbkFuc3dlcmluZyxcbiAgcmVxdWVzdCxcbiAgc2VudGVuY2VTaW1pbGFyaXR5LFxuICBzdHJlYW1pbmdSZXF1ZXN0LFxuICBzdW1tYXJpemF0aW9uLFxuICB0YWJsZVF1ZXN0aW9uQW5zd2VyaW5nLFxuICB0YWJ1bGFyQ2xhc3NpZmljYXRpb24sXG4gIHRhYnVsYXJSZWdyZXNzaW9uLFxuICB0ZXh0Q2xhc3NpZmljYXRpb24sXG4gIHRleHRHZW5lcmF0aW9uLFxuICB0ZXh0R2VuZXJhdGlvblN0cmVhbSxcbiAgdGV4dFRvSW1hZ2UsXG4gIHRleHRUb1NwZWVjaCxcbiAgdG9rZW5DbGFzc2lmaWNhdGlvbixcbiAgdHJhbnNsYXRpb24sXG4gIHZpc3VhbFF1ZXN0aW9uQW5zd2VyaW5nLFxuICB6ZXJvU2hvdENsYXNzaWZpY2F0aW9uLFxuICB6ZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb25cbn07XG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwidGFza3NfZXhwb3J0cyIsImF1ZGlvQ2xhc3NpZmljYXRpb24iLCJhdWRpb1RvQXVkaW8iLCJhdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvbiIsImNoYXRDb21wbGV0aW9uIiwiY2hhdENvbXBsZXRpb25TdHJlYW0iLCJkb2N1bWVudFF1ZXN0aW9uQW5zd2VyaW5nIiwiZmVhdHVyZUV4dHJhY3Rpb24iLCJmaWxsTWFzayIsImltYWdlQ2xhc3NpZmljYXRpb24iLCJpbWFnZVNlZ21lbnRhdGlvbiIsImltYWdlVG9JbWFnZSIsImltYWdlVG9UZXh0Iiwib2JqZWN0RGV0ZWN0aW9uIiwicXVlc3Rpb25BbnN3ZXJpbmciLCJyZXF1ZXN0Iiwic2VudGVuY2VTaW1pbGFyaXR5Iiwic3RyZWFtaW5nUmVxdWVzdCIsInN1bW1hcml6YXRpb24iLCJ0YWJsZVF1ZXN0aW9uQW5zd2VyaW5nIiwidGFidWxhckNsYXNzaWZpY2F0aW9uIiwidGFidWxhclJlZ3Jlc3Npb24iLCJ0ZXh0Q2xhc3NpZmljYXRpb24iLCJ0ZXh0R2VuZXJhdGlvbiIsInRleHRHZW5lcmF0aW9uU3RyZWFtIiwidGV4dFRvSW1hZ2UiLCJ0ZXh0VG9TcGVlY2giLCJ0b2tlbkNsYXNzaWZpY2F0aW9uIiwidHJhbnNsYXRpb24iLCJ2aXN1YWxRdWVzdGlvbkFuc3dlcmluZyIsInplcm9TaG90Q2xhc3NpZmljYXRpb24iLCJ6ZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb24iLCJwaWNrIiwibyIsInByb3BzIiwiYXNzaWduIiwibWFwIiwicHJvcCIsInR5cGVkSW5jbHVkZSIsImFyciIsInYiLCJpbmNsdWRlcyIsIm9taXQiLCJwcm9wc0FyciIsIkFycmF5IiwiaXNBcnJheSIsImxldHNLZWVwIiwia2V5cyIsImZpbHRlciIsImlzVXJsIiwibW9kZWxPclVybCIsInRlc3QiLCJzdGFydHNXaXRoIiwidGFza0NhY2hlIiwiTWFwIiwiQ0FDSEVfRFVSQVRJT04iLCJNQVhfQ0FDSEVfSVRFTVMiLCJIRl9IVUJfVVJMIiwiZ2V0RGVmYXVsdFRhc2siLCJtb2RlbCIsImFjY2Vzc1Rva2VuIiwib3B0aW9ucyIsImtleSIsImNhY2hlZFRhc2siLCJkYXRlIiwiRGF0ZSIsIm5vdyIsImRlbGV0ZSIsIm1vZGVsVGFzayIsImZldGNoIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJ0aGVuIiwicmVzcCIsImpzb24iLCJwaXBlbGluZV90YWciLCJjYXRjaCIsInRhc2siLCJzZXQiLCJzaXplIiwibmV4dCIsInZhbHVlIiwiSEZfSU5GRVJFTkNFX0FQSV9CQVNFX1VSTCIsInRhc2tzIiwibWFrZVJlcXVlc3RPcHRpb25zIiwiYXJncyIsImVuZHBvaW50VXJsIiwib3RoZXJBcmdzIiwiZm9yY2VUYXNrIiwiaW5jbHVkZUNyZWRlbnRpYWxzIiwidGFza0hpbnQiLCJ3YWl0X2Zvcl9tb2RlbCIsInVzZV9jYWNoZSIsImRvbnRfbG9hZF9tb2RlbCIsImNoYXRDb21wbGV0aW9uMiIsInJlcyIsIm9rIiwidGFza0luZm8iLCJtb2RlbHMiLCJpZCIsIkVycm9yIiwiYmluYXJ5IiwiZGF0YSIsInVybCIsIlR5cGVFcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiZW5kc1dpdGgiLCJjcmVkZW50aWFscyIsImluZm8iLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNpZ25hbCIsInJlc3BvbnNlIiwicmV0cnlfb25fZXJyb3IiLCJzdGF0dXMiLCJvdXRwdXQiLCJlcnJvciIsImJsb2IiLCJnZXRMaW5lcyIsIm9uTGluZSIsImJ1ZmZlciIsInBvc2l0aW9uIiwiZmllbGRMZW5ndGgiLCJkaXNjYXJkVHJhaWxpbmdOZXdsaW5lIiwib25DaHVuayIsImNvbmNhdCIsImJ1Zkxlbmd0aCIsImxlbmd0aCIsImxpbmVTdGFydCIsImxpbmVFbmQiLCJzdWJhcnJheSIsImdldE1lc3NhZ2VzIiwib25JZCIsIm9uUmV0cnkiLCJvbk1lc3NhZ2UiLCJtZXNzYWdlIiwibmV3TWVzc2FnZSIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImxpbmUiLCJmaWVsZCIsImRlY29kZSIsInZhbHVlT2Zmc2V0IiwiZXZlbnQiLCJyZXRyeSIsInBhcnNlSW50IiwiaXNOYU4iLCJhIiwiYiIsIlVpbnQ4QXJyYXkiLCJzdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJldmVudHMiLCJvbkV2ZW50IiwicHVzaCIsImRvbmUiLCJyZWFkIiwicGFyc2UiLCJyZWxlYXNlTG9jayIsIkluZmVyZW5jZU91dHB1dEVycm9yIiwiY29uc3RydWN0b3IiLCJpc1ZhbGlkT3V0cHV0IiwiZXZlcnkiLCJ4IiwibGFiZWwiLCJzY29yZSIsInRleHQiLCJCbG9iIiwibWFzayIsImdlbmVyYXRlZF90ZXh0IiwiYm94IiwieG1pbiIsInltaW4iLCJ4bWF4IiwieW1heCIsImJhc2U2NEZyb21CeXRlcyIsImdsb2JhbFRoaXMiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJiaW4iLCJmb3JFYWNoIiwiYnl0ZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImJ0b2EiLCJqb2luIiwicmVxQXJncyIsInBhcmFtZXRlcnMiLCJpbnB1dHMiLCJBcnJheUJ1ZmZlciIsImFycmF5QnVmZmVyIiwiaW1hZ2UiLCJkZWZhdWx0VGFzayIsImlzTnVtQXJyYXlSZWMiLCJtYXhEZXB0aCIsImN1ckRlcHRoIiwic2VxdWVuY2UiLCJ0b2tlbiIsInRva2VuX3N0ciIsImFuc3dlciIsImVuZCIsInN0YXJ0Iiwic3VtbWFyeV90ZXh0IiwiYWdncmVnYXRvciIsImNlbGxzIiwiY29vcmRpbmF0ZXMiLCJjb29yZCIsInRvQXJyYXkiLCJvYmoiLCJlbnRpdHlfZ3JvdXAiLCJ3b3JkIiwidHJhbnNsYXRpb25fdGV4dCIsImxhYmVscyIsIl9sYWJlbCIsInNjb3JlcyIsIl9zY29yZSIsImNob2ljZXMiLCJjcmVhdGVkIiwic3lzdGVtX2ZpbmdlcnByaW50IiwidXNhZ2UiLCJxdWVzdGlvbiIsIkhmSW5mZXJlbmNlIiwiZGVmYXVsdE9wdGlvbnMiLCJmbiIsImVudHJpZXMiLCJwYXJhbXMiLCJlbmRwb2ludCIsIkhmSW5mZXJlbmNlRW5kcG9pbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@huggingface/inference/dist/index.js\n");

/***/ })

};
;